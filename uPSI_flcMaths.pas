unit uPSI_flcMaths;
{
This file has been generated by UnitParser v0.7, written by M. Knight
and updated by NP. v/d Spek and George Birbilis. 
Source Code from Carlo Kok has been used to implement various sections of
UnitParser. Components of ROPS are used in the construction of UnitParser,
code implementing the class wrapper is taken from Carlo Kok's conv utility

}
interface
 

 
uses
   SysUtils
  ,Classes
  ,uPSComponent
  ,uPSRuntime
  ,uPSCompiler
  ;
 
type 
(*----------------------------------------------------------------------------*)
  TPSImport_flcMaths = class(TPSPlugin)
  public
    procedure CompileImport1(CompExec: TPSScript); override;
    procedure ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter); override;
  end;
 
 
{ compile-time registration functions }
procedure SIRegister_flcMaths(CL: TPSPascalCompiler);

{ run-time registration functions }
procedure RIRegister_flcMaths_Routines(S: TPSExec);

procedure Register;

implementation


uses
   flcStdTypes
  ,flcMaths
  ;
 
 
procedure Register;
begin
  RegisterComponents('Pascal Script', [TPSImport_flcMaths]);
end;

(* === compile-time registration functions === *)
(*----------------------------------------------------------------------------*)
procedure SIRegister_flcMaths(CL: TPSPascalCompiler);
begin
 CL.AddConstantN('Pi','Extended').setExtended( 3.14159265358979323846 + 0.26433832795028841971e-20 + 0.69399375105820974944e-40 + 0.59230781640628620899e-60 + 0.86280348253421170679e-80 + 0.82148086513282306647e-100 + 0.09384460955058223172e-120 + 0.53594081284811174502e-140 + 0.84102701938521105559e-160 + 0.64462294895493038196e-180);
 CL.AddConstantN('Pi2','Extended').setExtended( 6.283185307179586476925286766559006);
 CL.AddConstantN('Pi3','Extended').setExtended( 9.424777960769379715387930149838509);
 CL.AddConstantN('Pi4','Extended').setExtended( 12.56637061435917295385057353311801);
 CL.AddConstantN('PiOn2','Extended').setExtended( 1.570796326794896619231321691639751);
 CL.AddConstantN('PiOn3','Extended').setExtended( 1.047197551196597746154214461093168);
 CL.AddConstantN('PiOn4','Extended').setExtended( 0.785398163397448309615660845819876);
 CL.AddConstantN('PiSq','Extended').setExtended( 9.869604401089358618834490999876151);
 CL.AddConstantN('PiE','Extended').setExtended( 22.45915771836104547342715220454374);
 CL.AddConstantN('LnPi','Extended').setExtended( 1.144729885849400174143427351353059);
 CL.AddConstantN('LogPi','Extended').setExtended( 0.497149872694133854351268288290899);
 CL.AddConstantN('SqrtPi','Extended').setExtended( 1.772453850905516027298167483341145);
 CL.AddConstantN('Sqrt2Pi','Extended').setExtended( 2.506628274631000502415765284811045);
 CL.AddConstantN('LnSqrt2Pi','Extended').setExtended( 0.918938533204672741780329736405618);
 CL.AddConstantN('DegPerRad','Extended').setExtended( 57.29577951308232087679815481410517);
 CL.AddConstantN('DegPerGrad','Extended').setExtended( 0.9);
 CL.AddConstantN('DegPerCycle','Extended').setExtended( 360.0);
 CL.AddConstantN('GradPerCycle','Extended').setExtended( 400.0);
 CL.AddConstantN('GradPerDeg','Extended').setExtended( 1.111111111111111111111111111111111);
 CL.AddConstantN('GradPerRad','Extended').setExtended( 63.661977236758134307553505349006);
 CL.AddConstantN('RadPerDeg','Extended').setExtended( 0.017453292519943295769236907684886);
 CL.AddConstantN('RadPerGrad','Extended').setExtended( 0.015707963267948966192313216916398);
 CL.AddConstantN('RadPerCycle','Extended').setExtended( 6.283185307179586476925286766559);
 CL.AddConstantN('CyclePerDeg','Extended').setExtended( 0.002777777777777777777777777777778);
 CL.AddConstantN('CyclePerRad','Extended').setExtended( 0.15915494309189533576888376337251);
 CL.AddConstantN('CyclePerGrad','Extended').setExtended( 0.0025);
 CL.AddConstantN('E','Extended').setExtended( 2.718281828459045235360287471352663);
 CL.AddConstantN('E2','Extended').setExtended( 7.389056098930650227230427460575008);
 CL.AddConstantN('ExpM2','Extended').setExtended( 0.135335283236612691893999494972484);
 CL.AddConstantN('Ln2','Extended').setExtended( 0.693147180559945309417232121458177);
 CL.AddConstantN('Ln10','Extended').setExtended( 2.302585092994045684017991454684364);
 CL.AddConstantN('LogE','Extended').setExtended( 0.434294481903251827651128918916605);
 CL.AddConstantN('Log2','Extended').setExtended( 0.301029995663981195213738894724493);
 CL.AddConstantN('Log3','Extended').setExtended( 0.477121254719662437295027903255115);
 CL.AddConstantN('Sqrt2','Extended').setExtended( 1.414213562373095048801688724209698);
 CL.AddConstantN('Sqrt3','Extended').setExtended( 1.732050807568877293527446341505872);
 CL.AddConstantN('Sqrt5','Extended').setExtended( 2.236067977499789696409173668731276);
 CL.AddConstantN('Sqrt7','Extended').setExtended( 2.645751311064590590501615753639260);
  CL.AddTypeS('MFloat', 'Double');
  CL.AddTypeS('MFloatArray', 'DoubleArray');
  CL.AddTypeS('MFloat', 'Extended');
  CL.AddTypeS('MFloatArray', 'ExtendedArray');
  CL.AddTypeS('PMFloat', '^MFloat // will not work');
 CL.AddDelphiFunction('Procedure SetFPUPrecisionSingle');
 CL.AddDelphiFunction('Procedure SetFPUPrecisionDouble');
 CL.AddDelphiFunction('Procedure SetFPUPrecisionExtended');
 CL.AddDelphiFunction('Procedure SetFPURoundingNearest');
 CL.AddDelphiFunction('Procedure SetFPURoundingDown');
 CL.AddDelphiFunction('Procedure SetFPURoundingUp');
 CL.AddDelphiFunction('Procedure SetFPURoundingTruncate');
 CL.AddDelphiFunction('Function PolyEval( const X : MFloat; const Coef : array of MFloat; const N : Integer) : MFloat');
 CL.AddDelphiFunction('Function Sign0( const R : Integer) : Integer;');
 CL.AddDelphiFunction('Function Sign1( const R : Int64) : Integer;');
 CL.AddDelphiFunction('Function Sign2( const R : Single) : Integer;');
 CL.AddDelphiFunction('Function Sign3( const R : Double) : Integer;');
 CL.AddDelphiFunction('Function Sign4( const R : Extended) : Integer;');
 CL.AddDelphiFunction('Function FloatMod( const A, B : MFloat) : MFloat');
 CL.AddDelphiFunction('Function ATan360( const X, Y : MFloat) : MFloat');
 CL.AddDelphiFunction('Function InverseTangentDeg( const X, Y : MFloat) : MFloat');
 CL.AddDelphiFunction('Function InverseTangentRad( const X, Y : MFloat) : MFloat');
 CL.AddDelphiFunction('Function InverseSinDeg( const Y, R : MFloat) : MFloat');
 CL.AddDelphiFunction('Function InverseSinRad( const Y, R : MFloat) : MFloat');
 CL.AddDelphiFunction('Function InverseCosDeg( const X, R : MFloat) : MFloat');
 CL.AddDelphiFunction('Function InverseCosRad( const X, R : MFloat) : MFloat');
 CL.AddDelphiFunction('Function DMSToReal( const Degs, Mins, Secs : MFloat) : MFloat');
 CL.AddDelphiFunction('Procedure RealToDMS( const X : MFloat; var Degs, Mins, Secs : MFloat)');
 CL.AddDelphiFunction('Procedure PolarToRectangular( const R, Theta : MFloat; var X, Y : MFloat)');
 CL.AddDelphiFunction('Procedure RectangularToPolar( const X, Y : MFloat; var R, Theta : MFloat)');
 CL.AddDelphiFunction('Function Distance( const X1, Y1, X2, Y2 : MFloat) : MFloat');
 CL.AddDelphiFunction('Function IsPrime( const N : Int64) : Boolean');
 CL.AddDelphiFunction('Function IsPrimeFactor( const N, F : Int64) : Boolean');
 CL.AddDelphiFunction('Function PrimeFactors( const N : Int64) : Int64Array');
 CL.AddDelphiFunction('Function GCD5( const N1, N2 : Integer) : Integer;');
 CL.AddDelphiFunction('Function GCD6( const N1, N2 : Int64) : Int64;');
 CL.AddDelphiFunction('Function IsRelativePrime( const X, Y : Int64) : Boolean');
 CL.AddDelphiFunction('Function InvMod7( const A, N : Integer) : Integer;');
 CL.AddDelphiFunction('Function InvMod8( const A, N : Int64) : Int64;');
 CL.AddDelphiFunction('Function ExpMod9( A, Z : Integer; const N : Integer) : Integer;');
 CL.AddDelphiFunction('Function ExpMod10( A, Z : Int64; const N : Int64) : Int64;');
 CL.AddDelphiFunction('Function Jacobi( const A, N : Integer) : Integer');
 CL.AddConstantN('FactorialMaxN','LongInt').SetInt( 1754);
 CL.AddConstantN('FactorialMaxN','LongInt').SetInt( 170);
 CL.AddDelphiFunction('Function Factorial( const N : Integer) : MFloat');
 CL.AddDelphiFunction('Function Combinations( const N, C : Integer) : MFloat');
 CL.AddDelphiFunction('Function Permutations( const N, P : Integer) : MFloat');
 CL.AddDelphiFunction('Function Fibonacci( const N : Integer) : Int64');
 CL.AddDelphiFunction('Function GammaLn( X : Extended) : Extended');
 CL.AddDelphiFunction('Procedure FourierTransform( const AngleNumerator : MFloat; const RealIn, ImagIn : array of MFloat; var RealOut, ImagOut : MFloatArray)');
 CL.AddDelphiFunction('Procedure FFT( const RealIn, ImagIn : array of MFloat; var RealOut, ImagOut : MFloatArray)');
 CL.AddDelphiFunction('Procedure InverseFFT( const RealIn, ImagIn : array of MFloat; var RealOut, ImagOut : MFloatArray)');
 CL.AddDelphiFunction('Procedure CalcFrequency( const FrequencyIndex : Integer; const RealIn, ImagIn : array of MFloat; var RealOut, ImagOut : MFloat)');
 CL.AddDelphiFunction('Function SecantSolver( const f : fx; const y, Guess1, Guess2 : MFloat) : MFloat');
 CL.AddDelphiFunction('Function NewtonSolver( const f, df : fx; const y, Guess : MFloat) : MFloat');
 CL.AddDelphiFunction('Function FirstDerivative( const f : fx; const x : MFloat) : MFloat');
 CL.AddDelphiFunction('Function SecondDerivative( const f : fx; const x : MFloat) : MFloat');
 CL.AddDelphiFunction('Function ThirdDerivative( const f : fx; const x : MFloat) : MFloat');
 CL.AddDelphiFunction('Function FourthDerivative( const f : fx; const x : MFloat) : MFloat');
 CL.AddDelphiFunction('Function SimpsonIntegration( const f : fx; const a, b : MFloat; N : Integer) : MFloat');
 CL.AddDelphiFunction('Procedure Test');
end;

(* === run-time registration functions === *)
(*----------------------------------------------------------------------------*)
Function ExpMod10_P( A, Z : Int64; const N : Int64) : Int64;
Begin Result := flcMaths.ExpMod(A, Z, N); END;

(*----------------------------------------------------------------------------*)
Function ExpMod9_P( A, Z : Integer; const N : Integer) : Integer;
Begin Result := flcMaths.ExpMod(A, Z, N); END;

(*----------------------------------------------------------------------------*)
Function InvMod8_P( const A, N : Int64) : Int64;
Begin Result := flcMaths.InvMod(A, N); END;

(*----------------------------------------------------------------------------*)
Function InvMod7_P( const A, N : Integer) : Integer;
Begin Result := flcMaths.InvMod(A, N); END;

(*----------------------------------------------------------------------------*)
Function GCD6_P( const N1, N2 : Int64) : Int64;
Begin Result := flcMaths.GCD(N1, N2); END;

(*----------------------------------------------------------------------------*)
Function GCD5_P( const N1, N2 : Integer) : Integer;
Begin Result := flcMaths.GCD(N1, N2); END;

(*----------------------------------------------------------------------------*)
Function Sign4_P( const R : Extended) : Integer;
Begin Result := flcMaths.Sign(R); END;

(*----------------------------------------------------------------------------*)
Function Sign3_P( const R : Double) : Integer;
Begin Result := flcMaths.Sign(R); END;

(*----------------------------------------------------------------------------*)
Function Sign2_P( const R : Single) : Integer;
Begin Result := flcMaths.Sign(R); END;

(*----------------------------------------------------------------------------*)
Function Sign1_P( const R : Int64) : Integer;
Begin Result := flcMaths.Sign(R); END;

(*----------------------------------------------------------------------------*)
Function Sign0_P( const R : Integer) : Integer;
Begin Result := flcMaths.Sign(R); END;

(*----------------------------------------------------------------------------*)
procedure RIRegister_flcMaths_Routines(S: TPSExec);
begin
 S.RegisterDelphiFunction(@SetFPUPrecisionSingle, 'SetFPUPrecisionSingle', cdRegister);
 S.RegisterDelphiFunction(@SetFPUPrecisionDouble, 'SetFPUPrecisionDouble', cdRegister);
 S.RegisterDelphiFunction(@SetFPUPrecisionExtended, 'SetFPUPrecisionExtended', cdRegister);
 S.RegisterDelphiFunction(@SetFPURoundingNearest, 'SetFPURoundingNearest', cdRegister);
 S.RegisterDelphiFunction(@SetFPURoundingDown, 'SetFPURoundingDown', cdRegister);
 S.RegisterDelphiFunction(@SetFPURoundingUp, 'SetFPURoundingUp', cdRegister);
 S.RegisterDelphiFunction(@SetFPURoundingTruncate, 'SetFPURoundingTruncate', cdRegister);
 S.RegisterDelphiFunction(@PolyEval, 'PolyEval', cdRegister);
 S.RegisterDelphiFunction(@Sign0, 'Sign0', cdRegister);
 S.RegisterDelphiFunction(@Sign1, 'Sign1', cdRegister);
 S.RegisterDelphiFunction(@Sign2, 'Sign2', cdRegister);
 S.RegisterDelphiFunction(@Sign3, 'Sign3', cdRegister);
 S.RegisterDelphiFunction(@Sign4, 'Sign4', cdRegister);
 S.RegisterDelphiFunction(@FloatMod, 'FloatMod', cdRegister);
 S.RegisterDelphiFunction(@ATan360, 'ATan360', cdRegister);
 S.RegisterDelphiFunction(@InverseTangentDeg, 'InverseTangentDeg', cdRegister);
 S.RegisterDelphiFunction(@InverseTangentRad, 'InverseTangentRad', cdRegister);
 S.RegisterDelphiFunction(@InverseSinDeg, 'InverseSinDeg', cdRegister);
 S.RegisterDelphiFunction(@InverseSinRad, 'InverseSinRad', cdRegister);
 S.RegisterDelphiFunction(@InverseCosDeg, 'InverseCosDeg', cdRegister);
 S.RegisterDelphiFunction(@InverseCosRad, 'InverseCosRad', cdRegister);
 S.RegisterDelphiFunction(@DMSToReal, 'DMSToReal', cdRegister);
 S.RegisterDelphiFunction(@RealToDMS, 'RealToDMS', cdRegister);
 S.RegisterDelphiFunction(@PolarToRectangular, 'PolarToRectangular', cdRegister);
 S.RegisterDelphiFunction(@RectangularToPolar, 'RectangularToPolar', cdRegister);
 S.RegisterDelphiFunction(@Distance, 'Distance', cdRegister);
 S.RegisterDelphiFunction(@IsPrime, 'IsPrime', cdRegister);
 S.RegisterDelphiFunction(@IsPrimeFactor, 'IsPrimeFactor', cdRegister);
 S.RegisterDelphiFunction(@PrimeFactors, 'PrimeFactors', cdRegister);
 S.RegisterDelphiFunction(@GCD5, 'GCD5', cdRegister);
 S.RegisterDelphiFunction(@GCD6, 'GCD6', cdRegister);
 S.RegisterDelphiFunction(@IsRelativePrime, 'IsRelativePrime', cdRegister);
 S.RegisterDelphiFunction(@InvMod7, 'InvMod7', cdRegister);
 S.RegisterDelphiFunction(@InvMod8, 'InvMod8', cdRegister);
 S.RegisterDelphiFunction(@ExpMod9, 'ExpMod9', cdRegister);
 S.RegisterDelphiFunction(@ExpMod10, 'ExpMod10', cdRegister);
 S.RegisterDelphiFunction(@Jacobi, 'Jacobi', cdRegister);
 S.RegisterDelphiFunction(@Factorial, 'Factorial', cdRegister);
 S.RegisterDelphiFunction(@Combinations, 'Combinations', cdRegister);
 S.RegisterDelphiFunction(@Permutations, 'Permutations', cdRegister);
 S.RegisterDelphiFunction(@Fibonacci, 'Fibonacci', cdRegister);
 S.RegisterDelphiFunction(@GammaLn, 'GammaLn', cdRegister);
 S.RegisterDelphiFunction(@FourierTransform, 'FourierTransform', cdRegister);
 S.RegisterDelphiFunction(@FFT, 'FFT', cdRegister);
 S.RegisterDelphiFunction(@InverseFFT, 'InverseFFT', cdRegister);
 S.RegisterDelphiFunction(@CalcFrequency, 'CalcFrequency', cdRegister);
 S.RegisterDelphiFunction(@SecantSolver, 'SecantSolver', cdRegister);
 S.RegisterDelphiFunction(@NewtonSolver, 'NewtonSolver', cdRegister);
 S.RegisterDelphiFunction(@FirstDerivative, 'FirstDerivative', cdRegister);
 S.RegisterDelphiFunction(@SecondDerivative, 'SecondDerivative', cdRegister);
 S.RegisterDelphiFunction(@ThirdDerivative, 'ThirdDerivative', cdRegister);
 S.RegisterDelphiFunction(@FourthDerivative, 'FourthDerivative', cdRegister);
 S.RegisterDelphiFunction(@SimpsonIntegration, 'SimpsonIntegration', cdRegister);
 S.RegisterDelphiFunction(@Test, 'Test', cdRegister);
end;

 
 
{ TPSImport_flcMaths }
(*----------------------------------------------------------------------------*)
procedure TPSImport_flcMaths.CompileImport1(CompExec: TPSScript);
begin
  SIRegister_flcMaths(CompExec.Comp);
end;
(*----------------------------------------------------------------------------*)
procedure TPSImport_flcMaths.ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter);
begin
  RIRegister_flcMaths_Routines(CompExec.Exec); // comment it if no routines
end;
(*----------------------------------------------------------------------------*)
 
 
end.
